# 浏览器原理与HTTP协议

## 性能优化 大全

优化是针对输入URL到浏览器显示出页面这一过程做出的体现,围绕这一过程进行优化

1. DNS解析 TCP握手 无法优化
2. HTTP请求优化
   1. webpack优化
      1. 构建速度 , 打包优化(include/exclude,tree shaking/,cache,热模块替换,thread-loader,code split(实现多个js文件动态加载,需要哪个js文件才加载哪个,方法是使用多入口文件与动态导入))
   2. 图片资源优化
      1. base64与雪碧图(雪碧图是将很多小图片放在一张大图片上,利用css来展示的),base64是雪碧图的补充.使用base64编码后会导致图片的体积变得更大,大部分情况下只为了减少http请求的小文件使用base64.当然也可以使用iconfont
      2. 选择合适的图片格式JPEG PNG WebP(集多种优点与一身,但兼容性不太好)
      3. 使用图片懒加载
3. 存储优化??
   1. 浏览器缓存优化
      1. 使用适合的响应头配置HTTP缓存
      2. 依次根据浏览器缓存优先级设置缓存 memory cache (设置体积较小的缓存)
   2. 恰当使用本地存储(cookie localstorage indexDB)
4. 渲染优化
   1. 服务端渲染(解决了首屏加载过慢的问题,有利于SEO优化,但也带来了服务器资源压力过大的问题)
      1. 核心原理是利用框架的rendertoString方法,把虚拟DOM转化为真实DOM,然后mount上树.最后服务器发送HTML文件给客户端.
   2. defer与async,使用更好的css选择器,避免通配符等
   3. 回流与重绘:回流是位置,重绘是样式.回流必然导致重绘.因此要减少DOM操作
5. 其它优化
   1. 防抖与节流等

## 输入URL浏览器发生了什么 

### TCP连接过程

1. 用户输入URL地址,浏览器发送给DNS服务器,DNS服务器经过解析返回给浏览器服务器的IP与端口号
   1. 查找DNS并不是直接向DNS服务器寻找,先向浏览器缓存中寻找,再向操作系统缓存中寻找,再不行向hosts里寻找
   2. 本地DNS->根DNS->顶级DNS->权威DNS
2. 浏览器通过三次握手与服务器建立TCP连接
   1. 客户端发送SYN包,进入SYN_SENT状态,等待服务器收到 
   2. 服务器收到SYN包,确认后服务器发送SYN-ACK包,服务器进入SYN_RECV状态(客户端发送与接收的功能正常)
   3. 客户端收到SYN-ACK包,客户端发送ACK包 (服务器确认发送与接收功能正常) 此时服务器客户端都进入了ESTABLISHED状态,完成TCP握手
   4. SYN->SYN-ACK->ACK
3. 建立TCP连接以后,浏览器按照HTTP规定格式通过TCP向服务器发送"GET /HTTP/1.1"报文
4. 服务器收到报文后,根据HTTP协议解析报文,了解到浏览器的请求内容.了解到具体内容之后,根据HTTP协议拼接成符合要求的报文发送回去,此时发送回去的即为响应头为"HTTP/1.1 200 OK"的响应报文
   1. 收到报文的时候,服务器会在TCP层面返回一个ACK包确认请求,不过该包HTTP是看不到的
5. 浏览器收到报文进行解析,如果是个HTML文件,再通过浏览器引擎,JS引擎进行解析渲染.
   1. 在TCP层面,浏览器也要返回一个ACK确认响应报文收到了
6. TCP四次挥手
   1. 客户端发送FIN包,代表客户端发出连接释放报文,此时客户端进入FIN-WAIT-1状态
   2. 服务器发送ACK包,之后进入CLOSE-WAIT状态.客户端接收到ACK包,客户端进入FIN-WAIT-2状态,等待服务器的断开信息,此时此刻确保了客户端不在发送数据了,只保留接收数据的功能.
   3. 服务器发送FIN包,告诉客户端现在可以断开连接了.客户端接收到FIN包
   4. 客户端发送ACK包给服务器,服务器接收到ACK包,然后断开连接.如果客户端等一段时间后还没有收到服务器发来的信息,说明链接已经中断了.这两次挥手确保了服务器没有更多的信息要发送,实现了连接断开.
   5. FIN->ACK->FIN->ACK


### 浏览器中的进程与线程

线程是跑在进程里面的.一个进程里面可以有多个线程,一个线程只能对应一个线程

打开一个应用程序就相当于打开一个进程(浏览器中一个页面就是一个进程),系统将会为该进程分配一个全新的内存空间

创建进程以后,就可以创建线程来进行任务处理.可以创建多个线程来处理多个任务.同时处理多个任务的方式就叫做并行处理.

在应用程序中,可以创建新的进程进行资源处理,由于进程之间是相互独立的,使用新的进程可以避免一个进程挂掉以后,依然可以使用其它进程.

#### 在Chrome浏览器中

市面上大部分浏览器都是采取了多进程设计,如浏览器进程,渲染进程,GPU进程,插件进程.每个进程担任不同的角色.处理不同的任务.每个进程下有细分了许多的线程,处理该进程下更加细分的小人物.不同进程之间是相互隔离的.

```
理解用:
当我们是要浏览一个网页，我们会在浏览器的地址栏里输入URL，这个时候Browser Process会向这个URL发送请求，获取这个URL的HTML内容，然后将HTML交给Renderer Process，Renderer Process解析HTML内容，解析遇到需要请求网络的资源又返回来交给Browser Process进行加载，同时通知Browser Process，需要Plugin Process加载插件资源，执行插件代码。解析完成后，Renderer Process计算得到图像帧，并将这些图像帧交给GPU Process，GPU Process将其转化为图像显示屏幕。 即 标签页是渲染进程
```

Chrome浏览器是一个多进程程序,它主要包括

浏览器进程(Browser Process)

渲染进程(Renderer Process)

插件进程(Plugin Process)

GPU进程(GPU Process)

打开浏览器时会启动一个browser process,输入URL请求时会开启一个渲染进程(renderer process)

#### 渲染进程

渲染进程主要负责浏览器请求到html等代码后的解析与渲染工作,

它包括GUI线程,JS引擎线程,事件触发线程,定时器线程等

1. GUI线程就是走的关键渲染路径,通过构建dom tree css tree renderer tree 布局\绘制 重绘与回流的步骤,完成网页的渲染.

2. JS引擎线程主要负责解析js代码(v8引擎),其与GUI线程互斥,即会堵塞GUI线程的正常解析,我们常常说js是个单线程的语言,就是说的这一部分.

3. 事件触发线程:(event loop核心线程)触发的事件放入队列的尾部等待js引擎处理,所以为什么script会影响js解析,script属于js引擎线程,解析属于GUI线程,两者是互斥的.

### 浏览器渲染原理(关键渲染路径)

其实这一部分就是性能优化问题

浏览器渲染就是利用浏览器内核,也就是利用浏览器渲染引擎进行渲染

#### 构建DOM树

首先浏览器在请求资源时,往往服务器会优先返回index.html静态资源,浏览器拿到资源后,会进行词法分析与语法分析,构建一个DOM Tree,如此,DOM中的每一个节点都变为了可以被js操作的对象.

#### 样式计算

##### 1.转换结构

现在页面有哪些元素浏览器知道了,元素的样式是什么样浏览器还不知道.

在这个过程中,如果遇到link这样的标签,会进行异步请求css资源.或遇到内联样式或行内样式

浏览器对于这一部分的代码进行转换成css dom,可以在document.styleSheets里看到这个对象

##### 2.属性值标准化

现在有哪些样式浏览器已经知道了,然后浏览器还会进行样式的标准化,标准为便于浏览器理解的单位

##### 3.计算具体的样式值

首先样式值要受到css的继承特性的影响,继承就是子元素继承父元素的属性.

具体继承的方式在devtools可以看到

之后根据css中的层叠特性 最终计算完成的效果可以在computed面板中看到

##### 4.布局

经过之前的几个步骤,已经知道有哪些元素以及元素的样式信息,但还不知道位置信息,布局解决这个问题

###### (1)创建布局树(render tree)

根据DOM Tree与CSS Tree,生成所有需要渲染的元素,也就是render tree(不包括不需要渲染的元素如header,或者display:none的元素)

###### (2)布局计算

这里就可以进行计算布局了,但注意只是计算一下位置,并没有真正的渲染出来

经过以上的学习,我们可以看到要想页面能够迅速的渲染出来,优化html与css的体积是必要的,同时也要注意扁平化css选择器,也就是尽量避免css tree生成时的递归调用.

除此之外,script标签会阻塞html的解析,这就是为什么script标签会放到文件的最后面的原因.

使用defer可以允许script

#### 回流与重绘

浏览器根据render tree确认了需要渲染那些元素以及元素的样式与位置,开始渲染

回流:

render tree中部分或全部元素发生大小,结构或属性改变时,浏览器重新渲染部分或者全部文档内容叫做回流

重绘:仅仅改变元素的样式,并不改变元素在文档流中的位置.,这种情况下会引起重绘

回流必然导致重绘,重绘不一定会导致回流. 回流是元素位置的改变,重绘是元素样式的改变

在 HTML 页面内容被提交给渲染引擎 之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计 算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存 在布局树中。

##### 利用回流与重绘改善性能

布局结束后,并没有立即绘制画面,而是针对特定的布局树节点进行分层.



## Web存储

### cookie

由于HTTP是一种无状态协议,也就是建立连接,交换数据,断开连接这一过程后,再次发起请求,服务器并不知道客户端的身份.于是cookie应运而生,cookie是浏览器存储在本地的文件,用于下次客户端发送请求时告知服务端身份

修改cookie的api document.cookie

1. cookie被借用了存储的功能 
2. 大小限制在4KB
3. 每次都会携带在http头中，过量的cookie会损耗性能。
4. cookie是紧跟域名的，同一个域名下的所有请求，都会携带 Cookie。
5. 不够安全，服务器没法分辨用户和攻击者，攻击者可以读取网络上的其他用户的信息，包含HTTP Cookie的全部内容，以便进行中间的攻击。使用跨站点脚本技术可以窃取cookie等。

### cookie,session与token

在服务器上面生成session,包括sesson id与有效时间,服务器发送set-cookie请求给客户端,客户端在本地设置cookie,cookie的值就是session的值,有效时间就是session的有效时间.之所以使用session是为了避免直接存储用户名密码在本地防止被直接拿到

token是解决之前的身份认证的缺点所出现的.之前session需要在服务器上存储,如果服务器比较多,需要把session放在数据库上供服务器调用,这样会有安全隐患.token依然在服务器上生成,但服务器不保存,只保存token的密文.客户端将token保存在cookie或者localstorage上.

### WebStorage

1. 大小为5MB
2. 只发生在浏览器本地,不与服务器进行交换

## TCP/IP协议

### TCP与UDP的区别

1. TCP需要连接,UDP不用连接,直接传输数据
2. TCP是一对一的两点服务,UDP支持一对一与一对多
3. TCP是可靠交付,数据无差错,不丢失.UDP不保证可靠交付
4. !!(非必要不用回答)TCP有拥塞控制和流量控制,保证数据传输安全性.UDP没有,可以保证传输的效率
5. TCP面向:HTTP/FTP.UDP面向视频,音频等

## HTTP协议

http1.1一个重要的特点就是请求响应模式,即一个请求,一个应答

1. 请求应答模式->队头阻塞->持久连接(精灵图,data URL(base 64))
2. 明文传输,https加入的tls协议有让http有了更多次的握手,没有首部压缩,请求响应报文太大.

五层模型:应用层HTTP 传输层TCP UDP 网络层IP 链路层 物理层

http是一种网络协议,解决了应用程序之间如果传输数据,应该以怎么样的格式传输数据的问题.

其底层基于TCP/IP协议,该协议解决了应用程序之间如何建立通信连接,以及如何通信的问题.

特点:

1. 可扩展:请求响应头,请求方法,状态码等都可以灵活拓展,这些都是随着时代发展所添加上去的.
2. 可靠传输:HTTP基于TCP/IP协议,TCP本身是一种可靠传输协议,本质是对传输的数据做上一层包装(加上一些头信息)然后利用socket API发送.可靠的就是信息能过正确的送达
3. 请求应答模式:顺序进入,顺序出去.一个请求,一个应答
4. 无状态:收发双方不知道对方的身份每一次的报文传输也是完全独立的.TCP协议就是有状态的,UDP不是
   1. 无状态可以减轻服务器记忆状态的负担,还可以不用任何判断的进行负载均衡实现高并发

5. 明文传输:截获的流量就是真实浏览的内容
6. 性能: 请求应答模式导致的队头阻塞,即顺序发送的请求如果遇到堵塞,后面排队的请求也会一并被堵塞

实体数据:  

浏览器接收到HTTP数据后,并不知道该数据是什么样的格式,于是规定MIME.同时传输数据存在压缩,规定Encoding Type

1. MIME,规定HTTP的数据类别 type/subtype 
   1. 对应请求头:Accept 响应头:Content-type 这个过程叫做内容协商
   2. text image audio video application
2. Encoding-type:gzip deflate br
   1. 对应 accept-encoding content-encoding
3. 其它编码格式,语言等也属于内容协商
   1. 使用q=value设置权重

长短连接:

1. 短连接每一次都要TCP连接,太浪费
2. 长连接(默认开启)
   1. 请求/响应头:Connection:keep-alive
3. 解决对头阻塞的问题,使用并发连接,也就是对同一个域名开启多个长连接,但这回造成服务器资源的问题

重定向: 301与302状态码等可以认为是重定向

​	1.重定向的地址有响应头:Location:/xxx.html决定

Cookie: 为了解决HTTP无状态的问题,使用cookie让服务器记住状态,除此之外,还有广告跟踪的功能(第三方cookie)

	1. 响应头Set-cookie,发给客户端,
	1. 客户端下次再请求时,使用cookie请求头,标明自己的身份
	3. cookie的属性
	 	1. expires与max-age(max-age的优先级更高):设置cookie的失效时间
	 	2. domin;path指定cookie所属的域名和路径,在发送cookie前,浏览器对比URL中的域名与路径是否与cookie中的一致,如果一致再发送请求.
	 	3. HttpOnly属性:只能通过http协议传输cookie,防止了XSS攻击(防止了诸如document.cookie的方法获取cookie)
	 	4. SameSite属性:SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送， 而“SameSite=Lax”允许 GET/HEAD 等方法，但禁止 POST 跨站发送。这防止了CSRF攻击,即如果跨站传输cookie的话会被禁止

### HTTP缓存

强缓存:在资源未过期之前.浏览器都不会向服务器请求资源,直接使用本地的缓存

主要响应头: expires/ɪkˈspaɪr/到期,期限 cache-control

1. cache-control:max-age:5 这里的时间是从**报文创建的时间开始计算的**.即为Date字段
2. no-store:不存储缓存,用于数据变化非常频繁的数据,如秒杀界面
3. no-cache:使用缓存之前向服务器验证是否过期,不管缓存有没有过期
4. must-revalidate:如果缓存过期了,就向服务器校检,没过期直接用就可以了

![image-20221116200246630](https://cdn.jsdelivr.net/gh/CXGBro/image-repo/Picgo/image-20221116200246630.png)

​	5. 请求与响应都可以实现cache-control,如果请求头里添加了max-age=0,也就是缓存资源保存0s,也就相当于no-store.即服务器每次都要返回最新的资源

协商缓存:

1. 每一次都需要与服务器进行协商查看资源是否有更新,
   1. 如果更新就重新获取资源,即没有命中缓存就是使用新资源),返回200.
   2. 如果命中缓存,返回304,意味着重定向到使用本地自身的缓存.
2. 请求头:if-modified-since if-none-match 对比 last-modified etag

代理服务器

区分代理服务器↓

代理服务器作为客户端与服务器中间的中间人,一定程度上隐藏了服务器的真实信息1. 使用via字段,每次经过代理服务器时,都添加:via:proxy1,proxy2这样的字段

源服务器的缓存控制,也是在cache-control中设置的

1. private只能缓存在客户端,publlc缓存完全开发
2. 如果你登录论坛,返回的报文里set-cookie里有论坛ID,这个时候就不能再使用代理服务器缓存,只能存在客户端,否则就有泄露的风险
3. proxy-revalidate,缓存过期后,只验证到代理服务器这个级别就可以了
4. s-maxage,设置缓存在代理服务器上的缓存时间
5. no-transform:禁止代理服务器偷偷的改变一些数据

![image-20221116204510957](https://cdn.jsdelivr.net/gh/CXGBro/image-repo/Picgo/image-20221116204510957.png)

### HTTP状态码

响应报文中的响应头分为: HTTP版本号 状态码 原因(基本无用)

1. 1XX:表示处于通信的中间阶段,还需要继续操作

   101 Switching Protocols: 客户端通过Upgrade请求头告知更换请求协议,服务器同意更换,返回101状态码告知客户端更换协议

2. 2XX:表示服务端受到并成功处理了客户端的请求

   1. 200 OK:正确的处理了请求
   2. 204 Not Content:正确的处理了请求,但没有响应体
   3. 206 Partial Content:客户端发送部分请求,要求获得部分资源,服务器返回的响应体只是一部分的情况.响应体中还有content-range的响应头,用于标记响应数据的大小.HTTP 分块下载或断点续传的 基础

3. 3XX:表示客户端请求的数据发生变动,必须以新的URI发送请求

   1. 301 Moved Permanently:永久重定向,即资源不存在,需要改用新的URI
   2. 302 Found 临时重定向:资源临时不存在
   3. 304 Not Modified 用于浏览缓存,可以理解为:重定向到已经缓存的文件上
   4. (以下非常用)303 307 308

4. 4XX:表示客户端出现错误,请求报文有问题导致的.

   1.  400 通用错误码,无法判断到底哪里出错
   2.  403 服务器禁止访问资源
   3.  404 资源在服务器上没有找到

5. 5XX:服务器处理出错

   1.  500 不知道什么错误,就是出错
   2.  502 一般服务器为网关或者代理的时候出现,表示代理服务器正常,但原服务器出现了故障
   3.  503 服务器正忙,是个临时状态.


### 请求方法

1. GET/HEAD
   1. HEAD类似GET,但是只返回响应头
2. POST/PUT
   1. 在语义上,POST是,新建的含义,PUT是修改的含义,但在实际操作中,区别不大
3. DELETE
4. OPTIONS
   1. 让服务器列出服务器所支持的请求方法

## HTTPS

http是明文传输,使用它来传输非常的不安全

https相比较http最大的变化就是下层协议变成了SSL/TLS

TLS是它的正式姓名,SSL只是习惯叫法

除此之外,TLS协议的加入导致了除了TCP的三次握手连接外,还多了TLS的三次握手

![image-20221115204258145](https://cdn.jsdelivr.net/gh/CXGBro/image-repo/Picgo/image-20221115204258145.png)

### 对称加密与非对称加密

1. 加密和解密的密钥都只是一个  

   在TLS中,常用的加密算法是:AES与ChaCha20

2. 公钥发给任何人,私钥只能自己保管

   常用的加密算法是: RSA 与 ECC

### 在TLS中使用的是混合加密

1. 首先使用非对称加密,解决密钥传输问题
2. 生成一个会话密钥,使用公钥加密这个会话密钥,发给接收方,接收方使用私钥解密,就完成了会话密钥的传输
3. 之后的方法就是用对称加密

### 摘要算法

混合加密并不能完全保证安全,摘要算法是为了保证消息的完整性

发送消息给服务器时,带上一个SHA-2的摘要,网站收到信息后计算摘要,然后进行对比.如果一致即说明消息完整.(注意要把消息与摘要通过会话密钥同时加密,防止摘要也被修改)

### 数字签名

数字签名存在的目的是保证双方的**身份认证**信息

数字签名的原理就是将非对称加密的原理返回来,以前是公钥加密,私钥解密.现在是私钥加密,公钥解密

通过私钥加密传输密文的摘要后的内容即为数字签名

浏览器通过自己的私钥加密发送给服务器的信息的摘要,服务器通过公钥解密后发现和接收的内容的摘要一致,服务器就确认了浏览器的身份信息.反过来也一样

### 数字证书认证机构(CA)

公钥任何人都有,可是怎么确定这个公钥就是某个网站公开的呢?使用CA

CA完整的证明了公钥的所有者信息,形成了数字证书

数字证书的级别: DV <OV< EV,在于数字证书的可信程度

CA证明自己的方法:根证书

## HTTP2

HTTP2相比较1,在规范上没有太大的变化,保留了协议名:http/https,这很好的保证了网站的兼容性

1. 头部压缩: 

   1. http1时期,通过content-encoding字段指定body的压缩格式,但是header的大小与内容依然很多 .使用HPACK算法进行头部压缩

2. 二进制格式

   由明文转换为二进制格式,把原来的“Header+Body”的消息“打散”为 数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放 实体数据。这提高了数据传输的效率

   改变了明文传输的问题.便于浏览器解析

3. 多路复用

   对往返的消息分配一个唯一的流ID,这样数据帧有了先后顺序,就可以正确的组成请求与响应把报文

   如此,流可以发送多个帧序列,也就是多路复用,

   这样也就实现了单一的TCP连接传输多个数据

   改变请求响应的应答模式,服务器也可以主动的发送流给客户端,这叫做服务器推送

4. 强化安全

   在实际的应用场景上HTTP2就是使用https

## HTTP3

HTTP2的问题在于,多路复用用的都是同一个TCP通信线路,一旦在这个通信过程中发生了丢包现象,就会触发TCP的重传机制,导致所有的http请求都要等待丢包重传回来

http3直接将TCP协议改为了UDP协议.

但UDP不是可靠传输,于是又再UDP的上层添加了QUIC协议.模拟实现了可靠传输,但会造成兼容性的问题.

## 网络安全

### XSS攻击

Cross Site Scripting(跨站脚本),即进行

就是尽可能的把可执行代码嵌入到网站中执行

持久型:把代码直接注入到数据库中,这么做可能危害到所有的网站使用用户

举例:评论区内输入`<script>alert('hhh')</script>`这样的

非持久型:通过浏览器传参来注入代码

解决方案:

将用户输入的内容进行改变,防止用户输入不该输入的内容

1. 字符替换(将可能的攻击字符转换成没有攻击可能的字符)
2. 使用白名单过滤(白名单中标明只接受哪种类型的标签) 请见 js

### CSRF攻击

跨站请求伪造,黑客编写一个请求代码,诱导用户的点击或在用户不知情的情况下发起请求,如果后端没有相应的防御措施,就会误以为是用户真正的发送了请求,造成用户隐私泄露;

解决方案:

1.验证referer: 验证站点请求来源,如果来源不为本站点,则后端拒绝请求;

2.验证token: 每次访问时,服务器下发一个token,进行请求时,浏览器携带token与服务器进行认证,如果认证通过就允许请求